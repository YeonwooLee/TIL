

## #구상

### 시작시간: 08:50, 종료시간:10:30 (구상 소요 시간: 100)



#### [문제 정보]

>  algo / platform / rate / time / isSuccess / no / title / link
>
>  implementation

#### [문제 요약] 

```java
//static 영역
//[n][n] 배열에서 n은 항상 홀수;
//r행c열 첫칸은 1,1
//상어는 배열 중간 [n/2][n/2]에
//태풍은 언제나 반시계방향으로 돈다 상어가0부터 좌회전으로 123...
//int 터진1구슬
//int 터진2구슬
//int 터진3구슬

//블리자드페이즈 시작################################################
//마법시전 페이즈
//블자마법에는 방향d(상하좌우 1234) 거리s가 필요
//방향으로 거리만큼 구슬 제거

//구슬 폭파 페이즈
//while 터지기 없음
//구슬 빈칸 당겨짐 - 회오리로
//동번호 구슬 4개 이상 연속시 폭발(턴기준 동시)

//구슬변화페이즈
//1.연속으로 같은 숫자가 있는 구슬을 그룹이라고 한다.
//2. 그룹하나는 구슬 2개가(그룹길이,그룹대표수) 된다
//3.  순서대로 배열에 다시 들어간다
//4. 배열 끝까지 가면 넘치는 구슬은 x
//블리자드페이즈 종료################################################

//출력영역
//터진1+2*터진2+3*터진삼
```



#### [풀이 과정]

```java
static int[] removeDr = {0,-1,1,0,0};
static int[] removeDc = {0,0,0,-1,1};

static int[] dr = {0,1,0,-1}//좌하우상
static int[] dc = {-1,0,1,0}//좌하우상

static int[][] map;
static int[][] mapSeq = new int[n*n-1][2];
static void remove(int d, int s){//d방향 s거리 삭제
    //상어포지션 sr, sc
    int nr = sr;
    int nc = sc;
    for(int i=0;i<s;i++){
		//nr,nc계산
        int nr = nr + removeDr[d];
        int nc = nc + removeDc[d];
        map[nr][nc] = 0 ;//0이 공허구슬
    }
}


static void mkMapSeq(); //mapSeq를 만든다 - [블리자드순서i번쨰][r,c]

static void pullMarble(){//구슬당기기
    //maSeq순회
    	//이번칸 공백이면 이번칸=다음칸, 다음칸=공백
}

//구슬터지기
static void bomb(){
    ArrayList<int[]> list = new ArrayList<>();
    int s = mapSeq[0];
    int cnt = 1;
    list.add(mapSeq[0]의 {r,c})
    //mapSeq[1]부터 순회
    	//현재칸구슬번호가 s와 같으면 
    		//cnt ++
    		//list.add({r,c})
    	//다르면
    		nt>=4? -> list순회하면서 터뜨림; //터진구슬번호계수
         	list.clear;
    		s=mapSeq[현재];
    		list.add(mapSeq[현재]의{r,c});
			cnt=1;    
}

//구슬변화페이즈
//1.연속으로 같은 숫자가 있는 구슬을 그룹이라고 한다.
//2. 그룹하나는 구슬 2개가(그룹길이,그룹대표수) 된다
//3.  순서대로 배열에 다시 들어간다
//4. 배열 끝까지 가면 넘치는 구슬은 터진다
static void change(){
    //tempMap 만든다
    int idx = 0;
	WHLIE idx < mapSeq.length:
        int s = map의 mapSeq[0];//첫구슬
        int cnt = 1;
        //mapSeq[1]부터 순회
            //현재칸구슬번호가 s와 같으면 
                cnt ++
            //다르면
				tempMap[idx++] = cnt;
    			if(idx==mapSeq.length) breka
                tempMap[idx]=s
                s=mapSeq[현재];
                cnt=1;    
}

main(){
    //인풋받고
    mkMapSeq()
    //M번마법시전
        remove()
        wihle(bombIs)
        	pull()
        	bomb()
    	change()
}
```





#### [시간 복잡도]

#### [테스트케이스]

```markdown
//결과
인풋

//결과
인풋
```



## #구현

### 시작시간:10:40 , 종료시간:12:30 (구현 소요 시간: )

### 시작시간: , 종료시간: (구현 소요 시간: )



#### [해결 코드] 

```java
public class Main{
    public static void main(String[] args){
        //code
    }
}
```





#### [틀린 이유]

#### [느낀점]