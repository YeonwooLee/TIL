#### [문제 정보]
>  two_pointer / bj_s4 / 40 / O / 수들의 합2(https://www.acmicpc.net/problem/2003)

#### [문제 요약]
> 연속된 수의 합이 M이 되는 부분 수열이 몇개인지 구하기

#### [풀이 과정]
1. sum을 증가시키기 위해 뒤쪽 포인터 ++
  - 뒤포인터 == 배열길이? 종료
2. sum을 감소시키기 위해 앞쪽 포인터 ++
  - 앞 == 뒤? 뒤+=1
#### [시간 복잡도]
O(N)
#### [틀린 이유]

#### [느낀점]
#### [해결 코드]
```java
package bj_2003;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
public class Main {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	static int sum;
	
	static int front;
	static int back;
	
	static int[] arr;
	static int res;
	
	public static void main(String[] args) throws IOException{
		String[] NM = br.readLine().split(" ");
		int N = Integer.parseInt(NM[0]);
		int M = Integer.parseInt(NM[1]);
		
		arr = new int[N];//배열 생성
		String[] arrs = br.readLine().split(" ");
		for(int i=0;i<N;i++) {//배열 값 배정
			arr[i] = Integer.parseInt(arrs[i]);
		}
		front = 0;
		back = 0;
		sum = arr[front];
		while(back<N) {//back이 범위 안넘어간동안
			while(sum < M) {//sum이 구하는 수보다 작을 동안 증가
				back ++;//뒤쪽 포인터 한칸 전진(의미 = sum을 늘린다)
				if(back == N) {//범위초과
					break;
				}
				sum+=arr[back];//뒤쪽포인터 증가로 인한 sum 증가 반영
			}
			//sum >= M으로 내부와일루프 탈출
			if(sum==M) res ++;//sum == M인지 sum > M인지 판별하고 sum== M이면 res ++
			
			if(front == back) { //읽는 순서 2 - 읽는순서 1을 먼저 읽으시오
				back ++;
				if(back==N) break;
				sum+=arr[back];
			}
								//읽는 순서 1 - 이거 먼저 읽고 위에 루프 타고 내려오면서 읽는 순서 2를 읽으시오
			//앞쪽포인터 한칸 전진(의미 = sum을 줄인다)
			sum-=arr[front];
			front +=1;
		}
		System.out.println(res);
		
		
	}

}

```