#### [문제 정보]

>  two_pointer / bj_g2 / 120++ / XX / 가장 작은 직사각형(https://www.acmicpc.net/problem/1438)

#### [문제 요약]

> 점 N개 중 N/2개 이상을 포함한 직사각형 중 가장 넓이가 작은 직사각형의 넓이

#### [풀이 과정]

1. 점좌표 배열 만듦
2. 점좌표에서 x만 빼서 treesetX에 넣음 (treeset에 넣으면 정렬되고 중복 사라짐)
3. 점좌표에서 y만 빼서 treesetY에 넣음
4. treesetX treesetY를 arrX arrY화한다.
5. 0~arrX.length-1까지 for loop 순회하며 X1(y축에 가까운 x좌표)
   1. x1~arrX.length-1까지 for loop 순회하면 X2 구함
   2. y1(x축에 가까운 y좌표) =0 , y2 = 0
   3. while (y1 < arry.length && y2 < arry.length)
      1. 현재 arrx[x1] ~ [x2][y1][y2] 기준 겹치는 점 몇개인지 구함 (변 위에 있는 점까지 구함)
      2. 겹치는 점 수 N/2보다 부족하면 y2 추가
      3. 겹치는 점 수 N/2 이상이면 한칸씩늘려서

#### [시간 복잡도]

#### [틀린 이유]

- 1회차

  - 자바코드.질문1, 자바코드.질문2 이해못함

- 2회차

  - TreeSet 사용하지 않아서 중복이 있는 자료를 심지어 재 sort까지 해가면서 사용해야했음

  - pointer의 위치를 점이 존재하는 단위로 넓혀야 했는데 1씩 올렸음(공허공간까지 순회)

    


#### [느낀점]

- 질문 받아줄 사람이 너무 적다

#### [해결 코드]

#### #자바

```java
package daily.y_2023.m_01.d_30.bj_1438;

import java.util.*;


import java.io.*;

public class Main {
    static int N;
    static TreeSet<Integer> xtree;
    static TreeSet<Integer> ytree;
    static int[][] dot;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        dot = new int[N][2];
        xtree = new TreeSet<>();
        ytree = new TreeSet<>();
        StringTokenizer st;
        for(int i=0;i<N;i++) {
            st = new StringTokenizer(br.readLine());
            dot[i][0] = Integer.parseInt(st.nextToken());
            dot[i][1] = Integer.parseInt(st.nextToken());
            xtree.add(dot[i][0]);
            ytree.add(dot[i][1]);
        }
        Integer[] arrx = xtree.toArray(new Integer[0]);
        Integer[] arry = ytree.toArray(new Integer[0]);
        int minimum = Integer.MAX_VALUE;
        for(int x1=0;x1<arrx.length;x1++){//x1 = y축에 가까운 x점
            for(int x2=x1;x2<arrx.length;x2++){//x2 = y축에서 먼 x점
                int y1 = 0;//x축에 가까운 y점
                int y2 = 0;//x축에서 먼 y점
                while(y2 < arry.length && y1 < arry.length){
                    int cnt = countDots(arrx[x1],arry[y1],arrx[x2],arry[y2]);//임의의 사각형
                    if(cnt < N/2){
                        y2++;
                    } else{
                        minimum = Math.min(getArea(arrx[x1],arry[y1],arrx[x2],arry[y2]), minimum);
                        y1++;
                    }
                }
            }
        }
        System.out.println(minimum);
    }
    private static int getArea(int x1, int y1, int x2, int y2) {
        //질문2. +2는 무슨 의미인지 //답변2. 점 수 파악할 때 변과 겹치는 것 까지 세므로 한칸씩 넓힘
        int c = Math.abs(x1 - x2) + 2;
        int r = Math.abs(y1 - y2) + 2;
        return r * c;
    }

    //배열 전부 순회해서 내부에 점 몇개인지 파악
    private static int countDots(int x1, int y1, int x2, int y2) {
        int ret = 0;
        for(int i=0;i<N;i++) {
            int r = dot[i][0];
            int c = dot[i][1];
            //질문1. 변 위에 있는 점은 포함이 아니라는데 왜 초과, 미만이 아닌 이상, 이하로 카운트 하는지
            //답변1. 여기서 변 위에 있는걸 포함한 거로 하고 질문2에서 양옆으로 위아래로 늘린다
            if(x1 <= r && x2 >= r && y1 <= c && y2 >= c) {
                System.out.println("contain");
                ret++;
            }
        };
        return ret;
    }
}
```



#### #코틀린

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.lang.Integer.min
import java.lang.Math.abs
import java.util.TreeSet
import java.io.BufferedWriter
import java.io.OutputStreamWriter

val br = BufferedReader(InputStreamReader(System.`in`))
var result = Int.MAX_VALUE
val bw = BufferedWriter(OutputStreamWriter(System.out))
fun main() {
    val n = br.readLine().toInt()
    val m = n/2
    val xSet = TreeSet<Int>()
    val ySet = TreeSet<Int>()
    val dots = Array<Array<Int>>(n){Array<Int>(2){0} }
    for(i in 0 until n){
        val xy = br.readLine().split(" ")
        val x = xy[0].toInt()
        val y = xy[1].toInt()

        dots[i][0]=x
        dots[i][1]=y

        xSet.add(x)
        ySet.add(y)
    }
    val xMap:IntArray = xSet.toIntArray()
    val yMap:IntArray = ySet.toIntArray()

    for(x1 in 0 until xMap.size){
        for(x2 in x1 until xMap.size){
            var y1 = 0
            var y2 = 0
            while(y1<yMap.size && y2<yMap.size){
                val cnt = dCount(xMap[x1],xMap[x2],yMap[y1],yMap[y2],dots)
                if(cnt>=m){
                    result = min(result, area(xMap[x1],xMap[x2],yMap[y1],yMap[y2]))
                    y1++;
                }else{
                    y2++;
                }
            }

        }
    }
    bw.write(result.toString())
    bw.flush()
    bw.close()
}
fun area(x1:Int,x2:Int,y1:Int,y2:Int):Int{
    val x = abs(x1-x2)+2
    val y = abs(y1-y2)+2
    return x*y
}
fun dCount(x1:Int, x2:Int, y1:Int, y2:Int,dots:Array<Array<Int>>):Int{
    var cnt = 0
    for(dot in dots){
        if(dot[0]>=x1 && dot[0]<=x2 && dot[1]>=y1 && dot[1]<=y2) cnt++
    }
    return cnt
}

```

