#### [문제 정보]
>  {알고리즘} / {난이도} / {걸린시간} / {성공여부} / {제목(링크)}

#### [문제 요약]

> 문제 요약 및 추상화

#### [풀이 과정]

visited

for r in range(R):

​	for c in  range(C):

​		dfs(r,c) # depth 4에서 gg

​		tCheck(r,c) # rc 상하좌우 추가 후 하나씩빼면서 맥스



#tcheck



#### [시간 복잡도]

#### [틀린 이유]

#### [느낀점]
#### [해결 코드]
```
package org.opentutorials.javatutorials.eclipse;

import java.io.*;

public class helloworld {
	static int N, M; //행, 열
	
	static boolean[][] visited;//방문용
	static int[][] map;//필드
	
	
	
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	static int[] dr = {-1,0,1,0};
	static int[] dc = {0,-1,0,1};
	
	
	static int result = Integer.MIN_VALUE; // 결과
	public static void main(String[] args) throws IOException{
		//기본정보 입력
		String[] NM = br.readLine().split(" ");
		N = Integer.parseInt(NM[0]);
		M = Integer.parseInt(NM[1]);
		
		//맵구성 시작
		map = new int[N][M];
		visited = new boolean[N][M];
		for(int i=0;i<N;i++) {
			String[] line = br.readLine().split(" ");
			for(int j=0;j<M;j++) {
				map[i][j] = Integer.parseInt(line[j]);
			}
		}
		
		for(int r=0;r<N;r++) {//행 순회
			for(int c=0;c<M;c++) {//열 순회
				visited[r][c] = true;//사용처리
				dfs(r,c,1,map[r][c]); //행, 열, 추가된 숫자, 테트로모니합
				visited[r][c] = false;//사용해제
				
				tCheck(r,c);
			}
		}
		
		bw.write(Integer.toString(result));
		bw.flush();
		bw.close();
		

	}
	
	static void dfs(int sr, int sc, int depth, int curSum) {
		if(depth==4) {//추가된 숫자네게
			result = Math.max(result, curSum); // 결과 재정의
			return;
		}
		
		int nr,nc; //다음칸
		for(int i=0;i<4;i++) {
			nr = sr + dr[i];
			nc = sc + dc[i];
			
			if(nr<0 || nr>=N || nc<0 || nc >= M) continue;//범위초과
			if(visited[nr][nc]) continue;//이미방문
			
			visited[nr][nc] = true;//사용처리
			dfs(nr,nc,depth+1,curSum+map[nr][nc]); //다음분기
			
			//사용해제
			visited[nr][nc] = false;	
		}
		
	}
	
	static void tCheck(int sr, int sc) {
		int sum = map[sr][sc];//코어
		int tArea = 1; //+기호 만들면서 너비체크
		
		int nr,nc; // 상좌하우 더해서 + 기호 모양 만들기
		for(int i=0;i<4;i++) {
			nr = sr+dr[i];
			nc = sc+dc[i];
			
			if(nr<0 || nr>=N||nc<0||nc>=M) continue;//없는칸 배제
			tArea ++;
			sum += map[nr][nc];
		}
		
		if(tArea<=3) return; // t 안나오면 리턴
		else if(tArea==4) result=Math.max(result, sum);
		else {//4칸
			//한칸씩제거하고 result 재지정
			for(int i=0;i<4;i++) {
				
				int cur = sum - map[sr+dr[i]][sc+dc[i]];
				result = Math.max(result, cur);
			}
		}
		
	}

}

```