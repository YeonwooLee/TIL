

## #구상

### 크루스칼 학습용



#### [문제 정보]

>  algo / platform / rate / time / isSuccess / no / title / link
>
>  kruskal / bj / G4 / 30 / X / 1922 / 네트워크 연결

#### [문제 요약] 

> 기본 크루스칼

#### [풀이 과정]

```java

```





#### [시간 복잡도]

#### [테스트케이스]

```markdown

```



## #구현



#### [해결 코드] 

```kotlin
package d230227.bj_1992_네트워크연결

import java.util.StringTokenizer
import java.io.BufferedReader
import java.io.InputStreamReader


val br = BufferedReader(InputStreamReader(System.`in`))
lateinit var st:StringTokenizer
lateinit var parent:Array<Int>
var result = 0
fun main(){
    val N = br.readLine().toInt()//컴퓨터
    parent = Array<Int>(N+1){it}


    val M = br.readLine().toInt()//간선
    val edges = Array<Edge?>(M){null}

    for(i in 0 until M){
        st = StringTokenizer(br.readLine())
        val a = st.nextToken().toInt()
        val b = st.nextToken().toInt()
        val c = st.nextToken().toInt()
        edges[i] = Edge(a,b,c)
    }

    edges.sort()

    for(i in 0 until M){
        val curEdge = edges[i]!!
        val from = curEdge.a
        val to = curEdge.b
        val weight = curEdge.c

        val isGroup = cycleCheck(from, to)
        if(isGroup) continue
        union(from,to)
        result += weight

    }
    println(result)
}
fun union(a:Int, b:Int):Unit{
    val pa = findParent(a)
    val pb = findParent(b)
    if(pa<pb){
        parent[pb] = pa
    }else{
        parent[pa] = pb
    }

}
fun cycleCheck(from:Int, to:Int):Boolean{
    val fParent = findParent(from)
    val tParent = findParent(to)
    return fParent==tParent
}
fun findParent(num:Int):Int{
    if(parent[num]==num) return num
    val result = findParent(parent[num])
    parent[num] = result
    return result
}
class Edge(val a:Int,val b:Int,val c:Int) : Comparable<Edge>{
    override fun compareTo(other: Edge): Int {
        return c.compareTo(other.c)
    }

}
```





#### [틀린 이유]

- 크루스칼 학습용으로 보면서 함

#### [느낀점]

- 