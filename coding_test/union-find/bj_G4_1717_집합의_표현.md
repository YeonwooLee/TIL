```java
#### [문제 정보]

>  union-find / bj_G4 / 20 / O / 집합의표현(https://www.acmicpc.net/problem/1717)

#### [문제 요약]

> 0~n까지 자기 자신의 번호만을 원소로 갖는 ({0}, {1} ...{n}) n+1개의 집합 있음
>
> 0 a b 식으로 인풋 들어오면 a와 b집합을 합침
>
> 1 a b 식으로 인풋 들어오면 a원소와 b원소가 같은 집합에있는지에 따라 yes / no출력

#### [풀이 과정]

1. findparent(a) : a의 부모를 찾는다, 찾으면서 거쳐가는 원소들의 부모 갱신해둠
2. union(a,b): a와 b의 부모를 찾는다. a부모< b부모면 b부모's 부모 = a부모
   - 이 때, 부모의부모를 바꿔야지 a나 b의 직접 부모를 바꾸면 안된다.

#### [시간 복잡도]

O(1)

#### [틀린 이유]

#### [느낀점]



#### [해결 코드]

```java
package bj_1717;
import java.io.*;
import java.util.StringTokenizer;
public class Main {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	static int[] parent;
	public static void main(String[] args)throws IOException{
		StringTokenizer st= new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		parent = new int[n+1];//0~n
		for(int i=0;i<=n;i++) {
			parent[i] = i; //자신의 부모는 자신
		}
		
		for(int i=0;i<m;i++) {//다음 m개의 연산
			st = new StringTokenizer(br.readLine());
			int order = Integer.parseInt(st.nextToken());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			
			if(order==0) {
				union(a,b);
			}else if(order == 1) {
				boolean isFamily = isFamily(a,b);
				bw.write(isFamily?"yes\n":"no\n");
			}
			
		}
		bw.flush();
		bw.close();
	}
	
	//부모검색하며 부모갱신 -- 갱신 안할시 시간초과
	static int findParent(int a) {
		if(parent[a]==a) return a;
		else {
			return parent[a] = findParent(parent[a]);
		}
	}
	
	static void union(int a, int b) {
		int ap = findParent(a);//a부모
		int bp = findParent(b);//b부모
		
		//더작은부모로 통일
		if(ap<bp) parent[bp]=ap;
		else parent[ap] = bp;	
	}
	
	static boolean isFamily(int a, int b) {
		int ap = findParent(a);
		int bp = findParent(b);
		return ap==bp?true:false;
	}

}

```xxxxxxxxxx package bj_1717;import java.io.*;import java.util.StringTokenizer;public class Main {    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    static int[] parent;    public static void main(String[] args)throws IOException{        StringTokenizer st= new StringTokenizer(br.readLine());        int n = Integer.parseInt(st.nextToken());        int m = Integer.parseInt(st.nextToken());        parent = new int[n+1];//0~n        for(int i=0;i<=n;i++) {            parent[i] = i; //자신의 부모는 자신        }                for(int i=0;i<m;i++) {//다음 m개의 연산            st = new StringTokenizer(br.readLine());            int order = Integer.parseInt(st.nextToken());            int a = Integer.parseInt(st.nextToken());            int b = Integer.parseInt(st.nextToken());                        if(order==0) {                union(a,b);            }else if(order == 1) {                boolean isFamily = isFamily(a,b);                bw.write(isFamily?"yes\n":"no\n");            }                    }        bw.flush();        bw.close();    }        //부모검색하며 부모갱신 -- 갱신 안할시 시간초과    static int findParent(int a) {        if(parent[a]==a) return a;        else {            return parent[a] = findParent(parent[a]);        }    }        static void union(int a, int b) {        int ap = findParent(a);//a부모        int bp = findParent(b);//b부모                //더작은부모로 통일        if(ap<bp) parent[bp]=ap;        else parent[ap] = bp;       }        static boolean isFamily(int a, int b) {        int ap = findParent(a);        int bp = findParent(b);        return ap==bp?true:false;    }}java
```